name: Periodic Reconcile RFC Issues (every 3 hours)

on:
  schedule:
    - cron: '30 */3 * * *'  # every 3 hours at minute 30 (UTC)
  workflow_dispatch: {}

permissions:
  actions: read
  contents: read
  issues: write
  pull-requests: write

jobs:
  ping:
    name: Reconcile pipeline smoke test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: List RFC docs
        id: list
        shell: bash
        run: |
          set -euo pipefail
          ls -1 docs/RFC/RFC*.md 2>/dev/null | grep -E 'docs/RFC/RFC[0-9]{3}-.+\.md' | grep -v 'docs/RFC/README.md' > rfc_list.txt || true
          echo "Found RFCs:" && cat rfc_list.txt || true
          COUNT=$(wc -l < rfc_list.txt | tr -d ' ' || echo 0)
          echo "Found ${COUNT:-0} RFC file(s)"
          FILES=$(paste -sd, rfc_list.txt || true)
          echo "files=${FILES}" >> "$GITHUB_OUTPUT"

      - name: Mint GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Create missing RFC implementation issues
        if: ${{ steps.list.outputs.files != '' }}
        uses: actions/github-script@v7
        env:
          FILES: ${{ steps.list.outputs.files }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const filesCsv = process.env.FILES || '';
            const files = filesCsv.split(',').map(s => s.trim()).filter(Boolean);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            async function ensureLabel(name, color, description) {
              try { await github.rest.issues.getLabel({ owner, repo, name }); }
              catch {
                try { await github.rest.issues.createLabel({ owner, repo, name, color, description }); }
                catch (e) { core.warning(`ensureLabel(${name}) failed or exists: ${e.message}`); }
              }
            }
            await ensureLabel('rfc-implementation','5319e7','Implementation tracked from RFC');
            await ensureLabel('agent-work','1D76DB','Work authored by an AI agent');
            await ensureLabel('ai-review-requested','8a2be2','AI review requested');
            async function issueExists(rfcNumber) {
              const q = `repo:${owner}/${repo} in:title RFC${rfcNumber} type:issue state:open`;
              const res = await github.rest.search.issuesAndPullRequests({ q });
              return res.data.items.some(it => new RegExp(`\\bRFC${rfcNumber}\\b`).test(it.title));
            }
            for (const file of files) {
              const base = file.split('/').pop();
              const m = base.match(/^RFC(\d{3})-(.+)\.md$/);
              if (!m) continue;
              const rfcNumber = m[1];
              const titleText = m[2].replace(/-/g, ' ');
              const issueTitle = `RFC${rfcNumber}: ${titleText} - Implementation`;
              if (await issueExists(rfcNumber)) {
                core.info(`Open issue already exists for RFC${rfcNumber}.`);
                continue;
              }
              const body = [
                `This issue tracks implementation of RFC${rfcNumber}.`,
                '',
                `- RFC document: [${base}](./docs/RFC/${base})`,
                '- Labels: rfc-implementation, agent-work, ai-review-requested',
                '',
                'Acceptance Criteria:',
                '- Satisfy all RFC acceptance criteria',
                '- Tests implemented and passing',
                '- Integrates with existing systems as specified'
              ].join('\n');
              let attempt=0, lastErr;
              while (attempt < 3) {
                try {
                  await github.rest.issues.create({ owner, repo, title: issueTitle, body, labels: ['rfc-implementation','agent-work','ai-review-requested'] });
                  core.info(`Created issue: ${issueTitle}`);
                  lastErr=null; break;
                } catch (e) {
                  lastErr=e; attempt++; core.warning(`issues.create failed (attempt ${attempt}): ${e.message}`);
                  await new Promise(r=>setTimeout(r, 1000*attempt));
                }
              }
              if (lastErr) core.setFailed(`Failed to create issue for RFC${rfcNumber}: ${lastErr.message}`);
            }

      - name: Echo success
        run: |
          echo "Reconcile workflow minimal job OK"

  assign:
    name: Assign reconciled RFC issues (capacity-aware)
    needs: ping
    runs-on: ubuntu-latest
    steps:
      - name: Mint GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Capacity-aware assign and label
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        shell: bash
        run: |
          set -euo pipefail
          # Compute remaining capacity (max 3 active)
          ACTIVE=$(gh --repo "${{ github.repository }}" issue list --state open --label rfc-implementation --label agent-assigned --label in-progress --json number --jq 'length')
          ACTIVE=${ACTIVE:-0}
          REMAINING=$((3 - ACTIVE))
          echo "Active assigned RFCs: $ACTIVE. Remaining capacity: $REMAINING"
          if [ "$REMAINING" -le 0 ]; then
            echo "Capacity is full (3). Skipping."
            exit 0
          fi
          # Candidates: open RFC implementation issues
          IDS=$(gh --repo "${{ github.repository }}" issue list --state open --label rfc-implementation --json number --jq '.[].number' | tr '\n' ' ')
          ASSIGNED=0
          for id in $IDS; do
            [ "$ASSIGNED" -ge "$REMAINING" ] && break
            # Skip if already claimed or assigned
            CLAIMED=$(gh --repo "${{ github.repository }}" issue view "$id" --json labels --jq '[.labels[].name] | index("agent-assigned") // null')
            [ "$CLAIMED" != "null" ] && continue
            ASSIGNEES_COUNT=$(gh --repo "${{ github.repository }}" issue view "$id" --json assignees --jq '.assignees | length')
            [ "$ASSIGNEES_COUNT" -gt 0 ] && continue
            # Apply labels
            gh --repo "${{ github.repository }}" issue edit "$id" --add-label agent-assigned --add-label in-progress || true
            # Comment guidance
            TMP_FILE=$(mktemp)
            cat > "$TMP_FILE" << 'EOF'
Guidance for implementing this RFC:

- Follow the RFC acceptance criteria and update checkboxes as you progress.
- Create a feature branch per repo conventions.
- Write and run tests locally; aim for meaningful coverage.
- Open a draft PR early; request Gemini review by commenting `/gemini review`.
- Keep commits small and descriptive.

Refer to AI-REVIEWERS.md for Gemini Code Assist usage and labels.
EOF
            gh --repo "${{ github.repository }}" issue comment "$id" --body-file "$TMP_FILE" || true
            rm -f "$TMP_FILE"
            ASSIGNED=$((ASSIGNED + 1))
            echo "Assigned issue #$id ($ASSIGNED/$REMAINING)"
          done
          echo "Done. Assigned: $ASSIGNED"
